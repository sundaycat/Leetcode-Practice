# Binary Search

Binary search search in a sorted sequence for a target. It partition the sequence to two halves by `mid` and determine the answer in one of the halves. Each iteration reduces the search range by half.

### Q1: Ceiling of a Number

Given an array of numbers sorted in an ascending order, find the ceiling of a given number `key`. The ceiling of the `key` will be the smallest element in the given array greater than or equal to the `key`.

**example**

<pre>
Input: [1, 3, 8, 10, 15], key = 12  =>  Output: 4
The smallest number greater than or equal to '12' is '15' having index '4'.
</pre>

**case analysis**
Assume there exist duplicats numbers.

1. locate the element that is close to the key
2. check if the last two element satify the requirment.

**complexity analysis**
Time complexity: O(log N)

```python
def search_ceiling_of_a_number(arr, key):

    lt, rt = 0, len(arr) - 1
    while lt < rt - 1:

        mid = (lt + rt) // 2
        if arr[mid] == key:
            return mid
        elif arr[mid] < key:
            lt = mid + 1
        else:
            rt = mid - 1

    # postprocess the last two element
    if arr[lt] >= key:
        return lt
    if arr[rt] >= key:
        return rt

    return -1

arr = [1,3,8,10,15]
key = 12

arr = [1,3,8,15,15]
key = 15

arr = [1,3,8,10,15,15]
key = 15
```

**follow up**: Write a function to return the index of the floor of the ‘key’. If there isn’t a floor, return -1.

### [Q2][1]: Next Letter

Given an array of lowercase letters sorted in ascending order, find the smallest letter in the given array greater than a given ‘key’. (The given array is a circular list, which means the last letter is assumed to be connected with the first letter.)

**example**

<pre>
Input: ['a', 'c', 'f', 'h'], key = 'f'     =>                   Output: 'h'
Explanation: The smallest letter greater than 'f' is 'h' in the given array.
</pre>

**case analysis**

**solution 1**
When the loop stops, there are 3 possible values of (lt, rt) pairs as below:

<pre>
                        l   r
            T x T x x x x T x x x x x T x T 
            l   r                 l   r          
</pre>

- Case 1: (l, r) on the far left, then
  - If target < letters[lt] < letters[rt], return lt
  - If letters[lt] <= target < letterr[rt], return rt
- Case 2: (l, r) in the middle of the array.
  - Then target <= letters[lt] < letters[rt] is always true. return rt
- Case 3: (l, r) in the far right, then
  - If letters[lt] <= target < letters[rt], return rt
  - If letters[lt] <= letters[rt] <= target, return letter[0]

**solution 2**
when the loop stops, we have `lt = rt + 1`. so `lt` is always on the right side of rt when loops stops and this guarntees `lt` is the index of the smallest element greater than target.

<pre>
                            r l
                        x x x x x x x
</pre>

```python
def nextGreatestLetter_1(letters, str):

    lt, rt = 0, len(letters) - 1
    while lt < rt - 1:
        mid = (lt + rt) // 2
        # approching the target from the left.
        if letters[mid] <= target:
            lt = mid
        else:
            rt = mid

    # postprocessing the last two left elements
    if letters[lt] > target:
        return letters[lt]
    if letters[rt] > target:
        return letters[rt]
    return letters[0]


def nextGreatestLetter_2(letters: List[str], target: str):

    length = len(letters)
    lt, rt = 0, len(letters) - 1
    while lt <= rt:
        mid = (lt + rt) // 2
        if letters[mid] <= target:
            lt = mid + 1
        else:
            rt = mid - 1

    # % for the case that the targer larger than or equal to the largest letter in array
    return letters[lt % length]
```

### [Q3][2]: Number Range

Given an array of numbers sorted in ascending order, find the range of a given number `key`. The range of the `key` will be the first and last position of the `key` in the array.

**example**: [4, 6, 6, 6, 9], key = 6 => Output: [1, 3]

**case analysis**
We apply the binary search algorithm twice to search for the first and last occurrence of the target, respectively.

1. While searching the first occurrence
   - if mid == target, keep searching to the left, set `rt = mid`
   - if mid > target, keep searching to the left, set `rt = mid`
   - if mid < target, search to the right, set `lt = mid`
2. While searching the last occurrence
   - if mid == target, keep searching to the right, set `lt = mid`
   - if mid < target, keep searching to the right, set `lt = mid`
   - if mid > target, search to the left, set `rt = mid`

```Python
def findFirstOccurence(arr, key):

    lt, rt = 0, len(arr) - 1
    while lt < rt - 1:
        mid = (lt + rt) // 2
        if arr[mid] >= key:
            rt = mid
        else:
            lt = mid

    if arr[lt] == key:
        return lt
    if arr[rt] == key:
        return rt

    return -1


def findLastOccurence(arr, key):

    lt, rt = 0, len(arr) - 1
    while lt < rt - 1:
        mid = (lt + rt) // 2
        if arr[mid] <= key:
            lt = mid
        else:
            rt = mid

    if arr[rt] == key:
        return rt
    if arr[lt] == key:
        return lt

    return -1

def find_range(arr, key):

    if not arr or len(arr) == 0:
        return [-1, -1]

    lt = findFirstOccurence(arr, key)
    rt = findLastOccurence(arr, key)

    return [lt, rt]

arr = [4, 6, 6, 6, 9]
key = 6
print(find_range(arr, key))

arr = [1, 3, 8, 10, 15]
key = 10
print(find_range(arr, key))

arr = [1, 3, 8, 10, 15]
key = 12
print(find_range(arr, key))
```

### [Q4][3]: Search in a Sorted Infinite Array

Given an infinite sorted array (or an array with unknown size), find if a given number `key` is present in the array. Write a function to return the index of the `key` if it is present in the array, otherwise return -1.

**example**

<pre>
Input: [4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30], key = 16 => Output: 6
Explanation: The key is present at index '6' in the array.
</pre>

**case analysis**

1. find the proper bounds of the array that contains the target. A efficient way to find the bounds is to start at the beginning of the array with the bound's size as 1 and exponentially increase the bound's size (i.e., double it) until we find the bounds that can have the key.

2. apply binary search to find the index of the target.

**complexity analysis**
There are two parts of the algorithm. In the first part, we keep increasing the bound’s size exponentially (double it every time) while searching for the proper bounds. Therefore, this step will take O(logN). assuming that the array will have maximum ‘N’ numbers. In the second step, we perform the binary search which will take O(logN), so the overall time complexity of our algorithm will be O(logN+logN) which is asymptotically equivalent to O(logN).

Time complexity: O(log N) where N is the index of the key.

```Python
def search_in_infinite_array(reader, key):

    # find the proper bound that contains the key
    lt, rt = 0, 1
    while reader.get(rt) < key:
        newLt = rt + 1
        rt += (rt - lt + 1) * 2
        lt = newLt

    # find the key index via binary search in searchable bounds
    while lt <= rt:
        mid = lt + (rt - lt) // 2
        if reader.get(mid) == key:
            return mid
        elif reader.get(mid) < key:
            lt = mid + 1
        else:
            rt = mid - 1

    return -1
```

### Q5: Minimum Difference Element

Given an array of numbers sorted in ascending order, find the element in the array that has the minimum difference with the given `key`.

**Example**

<pre>
Input: [4, 6, 10], key = 7          =>          Output: 6
The difference between the key '7' and '6' is minimum than any other number in the array.
</pre>

**Case Analysis**
This problem is the same as finding the element that is closest to the target, which means we should include the middle element for the next iteration.

```Python
def search_min_diff_element(arr, key):

    lt, rt = 0, len(arr) - 1
    while lt < rt - 1:
        mid = (lt + rt) // 2
        if arr[mid] == key:
            return mid
        elif arr[mid] < key:
            lt = mid
        else:
            rt = mid

    ans = lt if abs(arr[lt] - key) <= abs(arr[rt] - key) else rt
    return ans

```

### [Q6][4]: Bitonic Array Maximum

Find the maximum value in a given Bitonic array. An array is considered bitonic if it is monotonically increasing and then monotonically decreasing.

<pre>
Input: [1, 3, 8, 12, 4, 2] => Output: 12
</pre>

**Case Analysis**
Q: How to determin the searching direction?
A: Compare mid and mid + 1

The main idea of binary search is we can drop half elements each time. The array doesn't necessaary to be sorted. There are 3 cases shown below, given that nums[i] != nums[i + 1] for all valid i.

- Case 1: if `mid - 1 < mid > mid + 1` is true, return mid as the peak
- Case 2: if `mid < mid + 1` is true, then there exist at least one peak on the right side. Set `lt = mid + 1`
- Case 3: if `mid > mid + 1` is true, then there exist at least one peak on the left side. Set `rt = mid - 1`
  - by case 1, we know `mid - 1 < mid > mid + 1` is false. That is, either `mid > mid - 1` or `mid > mid + 1` is false.
  - by case 2, we know `mid < mid + 1` is false, Note `nums[mid] != mid[mid + 1]`, then `mid > mid + 1` holds ture.
  - combine 3.1 and 3.2, we conclude `mid > mid - 1` must be false => `mid < mid - 1`.

We set the stop condition to `lt < rt -1` along with `lt = mid + 1` and `rt = mid - 1`, to avoid the index walk off the boundary of the array during comparison of `mid`, `mid - 1` and `mid + 1`.

```Python
def find_max_in_bitonic_array(arr):

    lt, rt = 0, len(arr) - 1
    while lt < rt - 1:
        mid = (lt + rt) // 2
        if arr[mid - 1] < arr[mid] > arr[mid + 1]:
            return arr[mid]
        elif arr[mid] < arr[mid + 1]:
            lt = mid + 1
        else:
            rt = mid - 1

    return arr[lt] if arr[lt] > arr[rt] else arr[rt]
```

---

# Problem Challenge

### Q1: Search Bitonic Array

Given a Bitonic array, find if a given ‘key’ is present in it. An array is considered bitonic if it is monotonically increasing and then monotonically decreasing. Write a function to return the index of the ‘key’. If the ‘key’ is not present, return -1.

<pre>
Input: [1, 3, 8, 4, 3], key=4 => Output: 3
</pre>

**Case Analysis**

1. Find the index of the peak of the array
2. Now, we break the array into two sub-array. One is sorted in ascending order, the order is sorted in decending order.
3. Apply binary search algorithm to the two sub-arrays.

*Note that only one peak exists in the bitonic array, so it guarantees the findPeak method finds the maximum. However, if there are multiple peaks in the array, findPeak will return either of the peaks and is not assured the one that returns is the maximum.*

``` Python
def search_bitonic_array(arr, key):

    peak = findPeak(arr)
    keyIdx = binarySearch(arr, key, 0, peak)
    if keyIdx == -1:
        keyIdx = binarySearch(arr, key, peak + 1, len(arr) - 1)

    return keyIdx

def findPeak(arr):

    lt, rt = 0, len(arr) - 1
    while lt < rt - 1:

        mid = (lt + rt) // 2
        if arr[mid - 1] < arr[mid] > arr[mid + 1]:
            return mid
        elif arr[mid] < arr[mid - 1]:
            lt = mid + 1
        else:
            rt = mid - 1

    return lt if arr[lt] > arr[rt] else rt

def binarySearch(arr, key, lt, rt):

    # decide sorted order of the current array
    direction = arr[lt] < arr[rt]
    while lt <= rt:
        mid = (lt + rt) // 2
        if arr[mid] == key:
            return mid
        elif arr[mid] < key:
            if direction:
                # increasing
                lt = mid + 1
            else:
                # decreasing
                rt = mid - 1
        else:
            if direction:
                rt = mid - 1
            else:
                lt = mid + 1

    return -1
```

### [Q2][7]: Search in Rotated Array

Given an array of numbers which is sorted in ascending order and also rotated by some arbitrary number, find if a given ‘key’ is present in it.

Write a function to return the index of the ‘key’ in the rotated array. If the ‘key’ is not present, return -1. (No duplicates in the array).

<pre>
Input: [10, 15, 1, 3, 8], key = 15    =>    Output: 1
Explanation: '15' is present in the array at index '1'.
</pre>

**case analysis**

1. If `mid == target`, return mid
2. If `mid >= left`, then left part [lt : mid] is sorted in ascending order.
    2.1 If `lt <= target < mid`, then target is in between [lt, mid). so set `rt = mid - 1`.
    2.2 else, the target fall in between (mid, rt]. set `lt = mid + 1`.

3. If `mid < left`, then right part `(mid+1 : rt]` is sorted in ascending orcer
    3.1 if `mid < target <= rt`, then target is in between (mid, rt]. so set `lt = mid + 1`
    3.2 else, the target fall in between [lt, mid), set `rt = mid - 1`

reference: https://www.youtube.com/watch?v=U8XENwh8Oy8

*since there are no duplicates in the given array, it is always easy to skip one part of the array in each iteration. However, if there are duplicates, it is not always possible to know which part is sorted.*

``` Python

def search(self, arr, key):

    lt, rt = 0, len(arr) - 1
    while lt <= rt:

        mid = (lt + rt) // 2
        if arr[mid] == key:
            return mid
        
        # [lt : mid] is sorted in a ascending order
        if arr[mid] >= arr[lt]:
            if arr[lt] <= key < arr[mid]:
                rt = mid - 1
            else:
                lt = mid + 1
        else: 
            # [mid + 1 : rt] is sorted in a sacending order
            if arr[mid] < key <= arr[rt]:
                lt = mid + 1
            else:
                rt = mid - 1
    
    return -1 
```

**Follow up**: How do we search in a sorted and rotated array that also has duplicates?

The only problematic scenario is when the numbers at indices `lt`, `mid` and `rt` are the same, as in this case, we can’t decide which part of the array is sorted. In such a case, the best we can do is to skip one number from both ends: `lt = lt + 1 & rt = rt - 1`.

### [Q3][5]: Rotation Count
Given an array of numbers which is sorted in ascending order and is rotated ‘k’ times around a pivot, find ‘k’. You can assume that the array **does not have any duplicates**.

**case analysis**

The key to solve this problem is realize a sorted array can be separated to two part by the middle element.
+ a subarray that is completely sorted
+ a subarray that is rotated sorted.

Note that, 

1. An interesting fact about the minimum element is that it is the only element in the given array which is smaller than its previous element.
2. It is similar to the question that find the minimum/maximum in a rotated sorted array.

<pre>
Input: [10, 15, 1, 3, 8]      =>      Output: 2
Explanation: The array has been rotated 2 times.
</pre>

``` Python
def count_rotations(arr):

    lt, rt = 0, len(arr) - 1
    while lt < rt - 1:
        mid = (lt + rt) // 2
        if arr[lt] <= arr[mid]:
            # left half is sorted, so we look to the right
            lt = mid
        else:
            # right half is sorted, so we look to the left.
            rt = mid
    
    # find the maximum index and minimum is next to it.
    maxIdx = lt if arr[lt] > arr[rt] else rt
    # if the array is completely sorted, return 1st element.
    return (maxIdx + 1) % len(arr)

print(count_rotations([10, 15, 1, 3, 8]))
print(count_rotations([4, 5, 7, 9, 10, -1, 2]))
print(count_rotations([1, 3, 8, 10]))
```

**[Follow up][6]**: How do we find the rotation count of a sorted and rotated array that has duplicates too?

**case analysis**
if there are duplicates in the array, and we may have lt == mid == rt, in such case, we can't decide which part of the rotated array is sorted. so we have to skip the the duplicates ones.

Maintain a variable to keep track of the minimum variable.
1. if the subarray is strictly sorted in an ascending order, return the min(res, nums(lt)) 
2. if the subarray is rotated sorted, then
    + 2.1 skip the duplicates as we can't decide which part of the subarray is sorted. Note that we will ignore the array which length is < 3.
    + 2.2 if left element <= middle, then this implies the following facts
        + a. The left half of current subarray is sorted in a ascending order
        + b. The extremum(minina or maxima) may lies on the right half. so we should keep searching for the minumum on the right side.
    + 2.3 if left element > middle, then this implies
        + a. the right half (mid : rt] is completely sorted
        + b. the extremum lies on the left half of the subarray. so we should search for the minmum on the left side.

Reference: https://www.youtube.com/watch?v=nIVW4P8b1VA

*Note, check leetcode 134 for the code.*


[1]: https://leetcode.com/problems/find-smallest-letter-greater-than-target/
[2]: https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/
[3]: https://leetcode.com/problems/search-in-a-sorted-array-of-unknown-size/
[4]: https://leetcode.com/problems/find-peak-element/
[5]: https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/
[6]: https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/
[7]: https://leetcode.com/problems/search-in-rotated-sorted-array/